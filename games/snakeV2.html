<!DOCTYPE html>
<html>
  <head>
    <title>Snake Game</title>
    <!-- Add some simple CSS styling -->
    <style>
      body {
        background-color: #222;
        margin: 0;
        overflow: hidden;
      }
      canvas {
        background-color: #333;
      }
    </style>
  </head>
  <body>
    <!-- Create the canvas element where the game will be displayed -->
    <canvas id="game-canvas" width="400" height="400"></canvas>

    <!-- Load the rainbow-colored snake image -->
    <!--<img id="snake-image" src="rainbowsnake.png" style="display:none">-->

    <!-- Add the JavaScript code for the game -->
    <script>
      // Set the size of each grid cell in the game
      const GRID_SIZE = 20;
      // Create an array of rainbow colors
      const colors = ['#FF0000', '#FFA500', '#FFFF00', '#008000', '#0000FF', '#4B0082', '#EE82EE'];

      // Set the initial direction and speed of the snake
      let direction = 'right';
      let speed = 100;
      // Set the initial position and length of the snake
      let snake = [{x: 160, y: 160}, {x: 140, y: 160}, {x: 120, y: 160}];
      // Set the initial position of the food
      let food = {x: 320, y: 320};
      // Get the canvas element and the 2D rendering context
      let canvas = document.getElementById('game-canvas');
      let ctx = canvas.getContext('2d');
      // Get the snake image element
      //let snakeImage = document.getElementById('snake-image');
      // Function to draw the snake on the canvas
	  const LIFE_ICON_SIZE = 20;
	  // Set the initial number of lives
	  let lives = 5;
	  
	  
      function drawSnake() {
        // Loop through each segment of the snake and draw it on the canvas
        for (let i = 0; i < snake.length; i++) {
          let segment = snake[i];
          ctx.fillStyle = colors[i%7];
          ctx.fillRect(segment.x, segment.y, GRID_SIZE, GRID_SIZE);
        }
      }
      // Function to draw the food on the canvas
      function drawFood() {
        ctx.fillStyle = '#f44336';
        ctx.fillRect(food.x, food.y, GRID_SIZE, GRID_SIZE);
      }

     // Function to update the game state

function update() {
  // Move the snake in the current direction
  let head = snake[0];
  let newHead;
  if (direction === 'right') {
    newHead = {x: head.x + GRID_SIZE, y: head.y};
  } else if (direction === 'left') {
    newHead = {x: head.x - GRID_SIZE, y: head.y};
  } else if (direction === 'up') {
    newHead = {x: head.x, y: head.y - GRID_SIZE};
  } else if (direction === 'down') {
    newHead = {x: head.x, y: head.y + GRID_SIZE};
  }
  snake.unshift(newHead);

  // Check if the snake has eaten the food
  let headX = newHead.x;
  let headY = newHead.y;
  if (headX === food.x && headY === food.y) {
    // Generate a new food position
    food = {x: Math.floor(Math.random() * 20) * GRID_SIZE, y: Math.floor(Math.random() * 20) * GRID_SIZE};
  } else {
    // Remove the tail of the snake to keep its length constant
    snake.pop();
  }
}

// Function to clear the canvas
function clear() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
}







// Function to check if the game is over
function checkGameOver() {
  // Check if the snake has collided with a wall
  let head = snake[0];
  if (head.x < 0 || head.x >= canvas.width || head.y < 0 || head.y >= canvas.height) {
    lives--;  // Decrement the number of lives
    if (lives > 0) {
      // Reset the game if there are still lives remaining
      //snake = [{x: 160, y: 160}, {x: 140, y: 160}, {x: 120, y: 160}];
    reverseSnake();
	  
      food = {x: 320, y: 320};
      return false;
    } else {
      // End the game if there are no lives remaining
      return true;
    }
  }

  // Check if the snake has collided with itself
  for (let i = 1; i < snake.length; i++) {
    let segment = snake[i];
    if (head.x === segment.x && head.y === segment.y) {
      lives--;  // Decrement the number of lives
      if (lives > 0) {
        // Reset the game if there are still lives remaining
        //snake = [{x: 160, y: 160}, {x: 140, y: 160}, {x: 120, y: 160}];
		
		reverseSnake();
        food = {x: 320, y: 320};
        return false;
      } else {
        // End the game if there are no lives remaining
        return true;
      }
    }
  }

  return false;
}

function reverseSnake() {
	// Reverse the order of the segments in the snake array
  snake.reverse();

  // Update the direction of the snake based on the reversed segments
  let head = snake[0];
  let tail = snake[snake.length - 1];
  if (head.x < tail.x) {
    direction = 'left';
  } else if (head.x > tail.x) {
    direction = 'right';
  } else if (head.y < tail.y) {
    direction = 'up';
  } else if (head.y > tail.y) {
    direction = 'down';
  }
}



// Function to display the game over screen
function gameOver() {
  clear();
  ctx.font = '48px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = 'white';
  ctx.fillText('Game Over', canvas.width / 2, canvas.height / 2);
}

// Function to run the game loop
function loop() {
  if (checkGameOver()) {
    gameOver();
  } else {
    setTimeout(function() {
      clear();
      update();
      drawFood();
      drawSnake();
	  drawLives();
      loop();
    }, speed);
  }
}

function drawLives() {
  // Set the font and text alignment for the lives display
  ctx.font = `${LIFE_ICON_SIZE}px sans-serif`;
  ctx.textAlign = 'right';
  ctx.textBaseline = 'top';

// Loop through each life and draw it on the canvas
  for (let i = 0; i < lives; i++) {
    // Set the position of the life icon
    let x = canvas.width - (i + 2) * (LIFE_ICON_SIZE + 6);
    let y = 0;

    // Draw the life icon as a heart shape
    //ctx.beginPath();
	ctx.fillStyle = '#FFC0CB';
    //ctx.moveTo(x, y + LIFE_ICON_SIZE);
    ctx.fillRect(x + LIFE_ICON_SIZE/2, y + LIFE_ICON_SIZE / 4, GRID_SIZE, GRID_SIZE);
	
}

}





// Start the game loop
loop();



// Define the variables that will be used to track the swipe gesture
let xDown = null;
let yDown = null;

// Handle the touchstart event
function handleTouchStart(evt) {
  // Get the x and y coordinates of the touch event
  xDown = evt.touches[0].clientX;
  yDown = evt.touches[0].clientY;
}

// Handle the touchmove event
function handleTouchMove(evt) {
  if (!xDown || !yDown) {
    return;
  }

  // Get the current x and y coordinates of the touch event
  let xUp = evt.touches[0].clientX;
  let yUp = evt.touches[0].clientY;

  // Calculate the distance the finger has moved in the x and y directions
  let xDiff = xDown - xUp;
  let yDiff = yDown - yUp;

  // Check if the gesture is a swipe
  if (Math.abs(xDiff) > Math.abs(yDiff)) {
    // Handle a swipe in the x direction
    if (xDiff > 0) {
      // Swipe left
      direction = 'left';
    } else {
      // Swipe right
      direction = 'right';
    }
  } else {
    // Handle a swipe in the y direction
    if (yDiff > 0) {
      // Swipe up
      direction = 'up';
    } else {
      // Swipe down
      direction = 'down';
    }
  }

  // Reset the x and y coordinates for the next touch event
  xDown = null;
  yDown = null;
}



// Add event listeners to handle key presses
document.addEventListener('keydown', function(event) {
  // Change the direction of the snake based on the key press
  if (event.keyCode === 37 && direction !== 'right') {
    direction = 'left';
  } else if (event.keyCode === 38 && direction !== 'down') {
    direction = 'up';
  } else if (event.keyCode === 39 && direction !== 'left') {
    direction = 'right';
  } else if (event.keyCode === 40 && direction !== 'up') {
    direction = 'down';
  }
});
	</script>
